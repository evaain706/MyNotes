


JS엔진에서는 하나의 실행 컨텍스트 스택이 존재


### 1. 실행 컨텍스트의 종류와 구조

자바스크립트 엔진은 코드를 실행할 때 **'콜 스택(Call Stack)'**이라는 통에 실행 컨텍스트를 쌓아 올리며 관리합니다.

1. **전역 실행 컨텍스트 (Global Execution Context):**
    
    - 브라우저에서 페이지가 로드되자마자 가장 먼저 생성되는 컨텍스트
        
    - 페이지가 종료될 때까지 유지
        
2. **함수 실행 컨텍스트 (Function Execution Context):**
    
    - 함수가 **호출(Call)될 때마다** 새로운 컨텍스트가 생성되어 스택에 쌓임
        
    - 함수 실행이 끝나면 스택에서 제거(Pop)

---
### 2. 실행 컨텍스트 내부 동작 과정 

``` js
// [1] 전역 컨텍스트 생성 단계 (코드 실행 전)
// - 전역 변수 a, 함수 outer를 '환경 레코드'에 기록 (호이스팅 발생)
// - a는 아직 값이 없으므로 undefined (var의 경우) 혹은 초기화 전 상태 (let/const)

var a = 1; // 전역 변수

function outer() {
  // [3] outer 함수 컨텍스트 생성 (outer 호출 시점)
  // - outer 내부의 변수 x, 함수 inner를 기록
  // - 'outerReference'는 전역 컨텍스트를 가리킴 (스코프 체인 연결)
  
  let x = 10;
  console.log(a); // 스코프 체인을 타고 전역의 a를 찾음 (1 출력)

  function inner() {
    // [5] inner 함수 컨텍스트 생성 (inner 호출 시점)
    // - inner 내부 변수 y 기록
    // - 'outerReference'는 outer 컨텍스트를 가리킴
    
    let y = 20;
    // console.log(x + y); // x는 outer에서 찾고, y는 내 거 사용 (30 출력)
  }

  inner(); // [4] inner 함수 호출 -> inner 컨텍스트 스택에 Push
  // [6] inner 함수 종료 -> inner 컨텍스트 Pop
}

outer(); // [2] outer 함수 호출 -> outer 컨텍스트 스택에 Push
// [7] outer 함수 종료 -> outer 컨텍스트 Pop
```

---

### 3. 실행 컨텍스트의 핵심 구성 요소 

실행 컨텍스트 내부에는 크게 3가지 중요한 정보가 담김 

#### A. 환경 레코드 (Environment Record)

- **역할:** 현재 컨텍스트 내의 **식별자(변수명, 함수명)**와 그 **값**을 저장하는 저장소
    
- **동작:** 코드가 실행되기 전에 엔진이 이 레코드를 먼저 훑음
    
    - "아, 여기 `var a`가 있고 `function outer`가 있구나" 하고 미리 기록
        
    - **이 과정이 바로 '호이스팅(Hoisting)'입니다.** 변수 선언이 코드 상단으로 끌어올려진 것처럼 동작하는 이유가 바로 이 '기록' 과정 때문
        

#### B. 외부 환경 참조 (Outer Environment Reference)

- **역할:** 현재 컨텍스트를 감싸고 있는 **상위(부모) 컨텍스트**를 가리키는 포인터
    
- **동작:** 현재 레코드에서 변수를 찾지 못하면, 이 포인터를 타고 상위 컨텍스트로 가서 찾음.
    
    - `inner` 함수에서 `x`를 찾을 때 없으면 `outer`로 가고, 거기서도 없으면 `전역`에서 찾음
        
    - **이 연결 리스트가 바로 '스코프 체인(Scope Chain)'임
        

#### C. This Binding

- **역할:** `this`가 무엇을 가리키는지를 결정
    
- **동작:** 함수가 어떻게 호출되었느냐에 따라 결정 (일반 함수 호출이면 전역 객체, 메서드 호출이면 해당 객체 등)

---

### 4. 요약 

1. **호이스팅의 원인:** 실행 컨텍스트가 생성될 때, 코드 실행 전에 변수와 함수 선언을 먼저 수집(Record)하기 때문에 발생.
    
2. **스코프 체인의 원리:** 변수를 찾을 때 현재 컨텍스트에 없으면 `Outer Reference`를 통해 상위 컨텍스트를 탐색하는 과정.
    
3. **클로저의 원리:** 이미 실행이 끝난 외부 함수의 변수를 내부 함수가 참조할 수 있는 이유는, 내부 함수의 `Outer Reference`가 죽지 않고 살아있는 외부 함수의 환경을 계속 가리키고 있기 때문임