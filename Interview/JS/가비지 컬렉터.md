

JS에서는 *가비지 컬렉터(GC)* 가 있어서 개발자가 직접 메모리 관리를 집중적으로 하지 않아도딤




오브젝트를 할당하면 메모리의 힙(Heap) 영역에 **실제 객체 데이터가 저장되고, 변수(`human`, `me`)가 있는 스택(Stack) 영역에는 그 힙 메모리의 '주소값(참조 값)'만 저장**

```js

// 1. 객체 생성
// Heap 영역: { age: 17, name: 'Kim' } 객체가 생성됨 (주소: 0x001이라 가정)
// Stack 영역: human 변수에 주소 0x001이 저장됨.
// [상태] 0x001 객체를 가리키는 변수(참조) 수: 1개 (human)
let human = {
  age: 17,
  name: 'Kim'
};

// 2. 참조 복사
// human이 가지고 있던 주소(0x001)를 me에게 복사함.
// 이제 me와 human은 같은 힙 메모리 공간(같은 객체)을 바라봄.
// [상태] 0x001 객체를 가리키는 변수 수: 2개 (human, me)
let me = human;

// 3. 참조 끊기 (1)
// me 변수에 null을 할당하여 0x001과의 연결을 끊음.
// 하지만 human이 여전히 0x001을 가리키고 있으므로 이 객체는 사라지지 않음.
// [상태] 0x001 객체를 가리키는 변수 수: 1개 (human) -> **GC 대상 아님**
me = null;

// 4. 참조 끊기 (2) - GC 발동 조건 충족
// human마저 연결을 끊음.
// 이제 힙 영역에 있는 { age: 17 ... } 객체(0x001)를 가리키는 변수가 하나도 없음.
// [상태] 0x001 객체를 가리키는 변수 수: 0개 -> **GC 대상(Garbage)이 됨**
human = null;

// 이후 자바스크립트 엔진(V8 등)의 가비지 컬렉터가 주기적으로 돌면서
// "어? 이 객체(0x001)에는 아무도 도달할 수 없네?" 하고 판단하여 메모리에서 해제
```


`GC또한 cpu를 사용하는'비용'이기 때문에 불필요한 할당은 줄이며 필요한 만큼 쓰는것이 중요`


``` js
const hi = 1; // 글로벌 변수는 앱이 종료될때까지 메모리에 유지
{

const localHi = 1; // 블럭이 끝나면 GC에 의해 자동으로 소멸

}
```