

JS는 싱글스레드 언어임 -> 두개 이상의 연산이나 함수를 동시에 실행불가능

처리가 오래걸리는 작업이 있다면 `Thread Block`이 일어나게됨

하지만 **JS 엔진은 긴 시간이 걸리는 작업들을 메인 스레드에서 직접 처리하지 않고**,  
**브라우저(Web API) 또는 런타임 환경(Node.js)의 별도 영역에 위임함**

-> 이렇게 메인 스레드가 아닌 WebAPi,Node.js등에서 처리하는 작업을 `비동기 작업`이라함

- `setTimeout`
- `setInterval`
- `fetch / axios`
- DOM 이벤트
- Promise 기반 비동기 작업
등으로 실행되며, 메인 스레드를 차단하지 않음


이렇게 위임된 작업은 실패,성공여부 상관없이 메인스레드가 결과를 알아야하는데,
이때 개발자는 **콜백 함수**를 함께 넘긴다(비동기함수를 호출할때, 처리완료시 메인스레드에서 함께 실행할 함수)

``` js
setTimeout(() => {
  console.log('완료'); 
}, 1000);
```

여기서
- `setTimeout` 자체는 즉시 실행되고
- 실제 타이머 작업은 Web API 영역에서 처리되며
- 콜백 함수는 **“나중에 실행될 함수”** 로 등록된다.

Web API에서 비동기 작업이 완료되면  
그 결과로 실행되어야 할 **콜백 함수는 즉시 실행되지 않고**,  
**Event Queue(Callback Queue)** 로 이동하게 된다.

`Event Queue`는

`지금 당장 실행할 수는 없지만, 실행 대기 중인 콜백 함수들을 보관하는 공간`이다

이후 **Event Loop**가 지속적으로 다음을 감시한다.

1. Call Stack이 비어 있는지 확인
2. 비어 있다면 Event Queue에 대기 중인 콜백이 있는지 확인
3. 있다면 콜백 함수를 Call Stack으로 이동시켜 실행


이 구조 덕분에

- JS는 여전히 **싱글 스레드**이지만
- 비동기 작업이 메인 스레드를 막지 않고
- 여러 작업을 동시에 처리하는 것처럼 보이게 된다.

`
