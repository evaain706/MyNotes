
### **자신의 강점과 약점은 무엇인가요?**

ex 저의 강점은 새로운 기술에 대한 열린 마음과 적극적인 학습 태도입니다. 또한, 문제 해결 능력과 논리적 사고 능력도 강점 중 하나입니다. 반면에 제 약점은 디테일한 부분에 대한 주의 부족입니다. 이를 보완하기 위해 더욱 신중하게 작업하고, 팀원들과 함께 코드 리뷰를 진행하는 등의 방법을 사용하고 있습니다.

---

## 직무선택이유 

저는 사용자가 직접 마주하는 인터페이스를 설계하고 개선하는 과정에 가장 큰 흥미를 느껴 프론트엔드를 선택했습니다.  
그리고 배워나가면서 같은 기능이라도 어떤 방식을 선택하느냐에 따라 `성능`과 `사용자 경험`이 달라진다는 점이 매력적으로 느껴졌습니다.  


---

### **가장 최근에 해결한 기술적인 문제는 무엇이었나요?**

모바일 사이즈 vh이슈

---


#### 기억에 남는 트러블 슈팅에 관련해 이야기해주세요.



  1. 문제 상황 (Situation)
  "LLM API를 활용해 실시간으로 퀴즈를 생성하는 기능을 구현했는데, LLM 특성상 응답 구조가 일관적이지 않아 간혹  파싱 에러가 발생하는 문제가 있었습니다. 이로 인해 React의 렌더링 과정에서 런타임 에러가 발생하면 전체 
  페이지가 언마운트되어 화면이 하얗게 변하는(White-out) 현상이 나타났습니다."


  2. 원인 분석 (Problem)
  "React의 기본 동작은 렌더링 중 에러 발생 시 전체 트리를 제거하는 것인데, API 에러는 비동기적으로 발생하기 때문에 일반적인 Error Boundary가 이를 즉시 포착하지 못한다는 점이 문제였습니다. 단순히 try-catch로 처리하면 사용자에게는 아무    
  반응 없는 먹통 화면만 남게 되었습니다."


  3. 해결 방법 (Action)
  "이를 해결하기 위해 '비동기 에러의 동기적 전파' 패턴을 적용했습니다.
   * 첫째, API 에러를 로컬 상태로 캡처한 뒤, 렌더링 시점에 해당 에러를 명시적으로 throw 하도록 구현했습니다.
   * 둘째, 에러 발생 가능성이 높은 퀴즈 카드 영역만 ErrorBoundary로 감싸 에러를 고립시켰습니다.
   * 셋째, Fallback UI에 '다시 시도(Retry)' 기능을 넣어 사용자가 새로고침 없이도 API를 재호출하여 서비스를 계속 이용할 수 있게 설계했습니다."


  4. 결과 (Result)
  "그 결과, LLM의 불안정한 응답에도 불구하고 페이지 전체가 크래시되는 현상을 0%로 막을 수 있었고, 사용자에게는 친절한 안내와 복구 수단을 제공함으로써 서비스 안정성과 UX를 동시에 크게 개선할 수 있었습니다."

  ---


  핵심 키워드 (이걸 섞어 쓰면 '고수' 느낌이 납니다)
   * 비결정적(Non-deterministic) 응답: LLM처럼 결과가 매번 달라질 수 있음을 표현.
   * 에러 고립(Isolation): 전체가 죽지 않게 특정 부분만 막았다는 의미.
   * 선언적 에러 처리: if-else 에러 처리보다 ErrorBoundary라는 컴포넌트로 깔끔하게 처리했음을 강조.
   * 자기 치유(Self-healing) UI: 사용자가 직접 문제를 해결(Retry)할 수 있게 만든 구조.

  ---

  💡 면접관이 던질 수 있는 추가 질문 대비


   * Q: 왜 `react-query`의 에러 핸들링을 쓰지 않고 직접 구현했나요?
       * A: "당시 프로젝트 구조상 전역적인 에러 처리보다는 특정 컴포넌트(퀴즈 카드)의 레이아웃을 유지하면서 부분적인 Fallback UI를 보여주는 것이 UX 관점에서 더 중요하다고 판단했습니다. 또한, Error Boundary를 직접 구현하며 React의 렌더링 
         메커니즘과 에러 전파 과정을 깊이 있게 이해해보고 싶었습니다."
   * Q: `getDerivedStateFromError`와 `componentDidCatch`의 차이는 무엇인가요?
       * A: "getDerivedStateFromError는 에러 발생 시 상태를 업데이트하여 Fallback UI를 렌더링하는 용도로 사용(정적 메서드)하고, componentDidCatch는 에러 로그를 외부 서비스(Sentry 등)에 기록하는 것과 같은 Side Effect를 처리하는 데        
         사용합니다."




---


## 갈등상황 & 극복과정

프로젝트 초반 역할 분배 후  팀원 한 분이 개인 사정으로 이탈하는 상황이 발생했습니다.  
우선  `각 파트의 예상 소요 시간을 공유`해본 뒤, `단순 균등 분배가 아니라` 팀원들의 `숙련도와 선호 영역을 고려`해 역할을 재조정했습니다.  
그 결과 일정 지연 없이 프로젝트를 마무리했고, `변수 발생 시 빠르게 재정렬하는 협업 경험`을 쌓았습니다.


---

## 협업 문제해결과정




---

## 1분 자기소개

안녕하십니까, 프론트엔드 개발자로 지원한 ○○○입니다.  


경험 성능


저는 Lighthouse와 같은  `성능 측정 도구`와 Zustand, TanStack Query 등을 활용해 `렌더링 최적화와  네트워크 요청 감소`를 이뤄내며 ,`사용자 경험`과 `성능`을 함께 고려하는 개발을 해왔습니다.  

협업

또한 여러 차례 팀 프로젝트를 수행하며 `스크럼 기반 이슈 공유`와 `코드 리뷰 문화`를 통해 `협업 생산성`을 높이는 경험을 쌓았습니다.  

현재는 주제선정부터 배포까지 전 과정을 단독으로 수행하는 개인 프로젝트를 진행하며, 프론트엔드 영역을 넘어 `시스템 전반의 흐름을 고려하는 시야`를 기르고있습니다.

이러한 경험을 바탕으로 `사용자 경험, 성능, 협업`을 모두 고려하는 개발자로서 기여하고 싶습니다.


