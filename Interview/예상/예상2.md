# 1️⃣ FRONTQUIZ (LLM 기반 퀴즈 플랫폼)

## ❓ Q1. LLM 응답을 JSON 스키마로 강제했다고 했는데, 구체적으로 어떻게 설계했나요?

> 근거: “프롬프트 엔지니어링을 통해 텍스트를 일관된 JSON 스키마로 응답받도록 설계”
> 
> 커리어12기_맹은빈_이력서

### 🔎 꼬리질문

- 모델이 JSON을 깨트렸을 때는 어떻게 대응했나요?
    
- Zod 같은 런타임 검증을 했나요?
    
- 프롬프트만으로 제어하는 건 위험하지 않나요?
    

### ✅ 예상답변 방향

- 프롬프트에 JSON 스키마 예시를 명시하고 “반드시 JSON으로만 응답하라”고 제약
    
- 서버단에서 `JSON.parse` 실패 시 재요청 로직
    
- TypeScript 타입만으로는 불충분 → 런타임 스키마 검증 도입
    
- 실패 시 ErrorBoundary → FallbackUI + 재요청 CTA
    

👉 추가로 더 좋은 답변은:

> “프롬프트 신뢰는 100% 불가능하다고 판단해 서버에서 Zod 기반 검증을 추가했고, 실패 시 자동 재시도 로직을 적용했습니다.”

---

## ❓ Q2. ErrorBoundary와 TanStack Query의 isError 처리는 왜 분리했나요?

> 근거: ErrorBoundary + isError 기반 FallbackUI
> 
> 커리어12기_맹은빈_이력서

### 🔎 꼬리질문

- 둘의 차이는 무엇인가요?
    
- 어떤 경우에 ErrorBoundary가 더 적합한가요?
    
- Suspense와 결합했다면 어떻게 설계했을까요?
    

### ✅ 예상답변 방향

- ErrorBoundary → 렌더링 단계 에러 (JS 에러)
    
- isError → 서버 응답 실패 (비동기 에러)
    
- LLM 파싱 오류는 JS 에러 → Boundary로 처리
    
- API 실패는 Query 상태로 제어
    

👉 여기서 깊이 있는 답변:

> “에러의 책임 범위를 분리해 UI 붕괴를 방지했습니다.”

---

## ❓ Q3. CLS 0.027, FCP 0.5s를 어떻게 달성했나요?

> 근거: Lighthouse 수치 언급
> 
> 커리어12기_맹은빈_이력서

### 🔎 꼬리질문

- Skeleton이 CLS를 줄이는 원리는?
    
- 이미지 최적화는?
    
- 폰트 전략은?
    

### ✅ 예상답변 방향

- Skeleton으로 고정 height 확보 → Layout shift 방지
    
- 이미지 width/height 명시
    
- Suspense fallback 최소화
    
- 불필요한 reflow 제거
    

👉 더 나은 답변:

> “단순 Skeleton이 아니라 실제 컨텐츠와 동일한 박스 구조를 유지했습니다.”

---

# 2️⃣ GLOBALNOMAD (Next.js 팀 프로젝트)

---

## ❓ Q4. API Route를 프록시로 사용한 이유는?

> 근거: “api route를 프록시로 사용”
> 
> 커리어12기_맹은빈_이력서

### 🔎 꼬리질문

- CORS 해결용인가요?
    
- 보안상 이점은?
    
- 단점은?
    

### ✅ 예상답변 방향

- 서버 간 통신으로 CORS 우회
    
- 백엔드 URL 은닉
    
- 에러 포맷 통일
    
- 토큰 서버측 처리 가능
    

👉 고급 답변:

> “SSR과 결합 시 쿠키 기반 인증을 안정적으로 처리할 수 있습니다.”

---

## ❓ Q5. Promise.allSettled를 사용한 이유는?

> 근거: 예약 달력에서 allSettled 사용
> 
> 커리어12기_맹은빈_이력서

### 🔎 꼬리질문

- Promise.all과 차이?
    
- 실패 월이 있으면?
    
- 캐싱 전략은?
    

### ✅ 예상답변 방향

- 일부 월 실패해도 전체 UI 붕괴 방지
    
- 성공한 월만 렌더링
    
- TanStack Query 캐시 활용
    

👉 더 좋은 답변:

> “UX상 일부 데이터만 보여주는 것이 전체 실패보다 낫다고 판단했습니다.”

---

## ❓ Q6. Zustand에서 selector 기반 구독을 왜 사용했나요?

> 근거: “Selector 기반 선택적 구독”
> 
> 커리어12기_맹은빈_이력서

### 🔎 꼬리질문

- shallow 비교는?
    
- Context와 차이?
    

### ✅ 예상답변 방향

- 전체 store 변경 → 전체 리렌더 방지
    
- 필요한 state만 구독
    
- shallow 비교로 참조 안정성 확보
    

👉 고급 답변:

> “예약 인터페이스는 state 변화가 빈번해 re-render cost 최적화가 중요했습니다.”

---

## ❓ Q7. Query Key Factory 패턴을 왜 도입했나요?

> 근거: QueryKey 중앙관리
> 
> 커리어12기_맹은빈_이력서

### 🔎 꼬리질문

- invalidate 전략은?
    
- 키가 바뀌면 어떤 일이 벌어지나요?
    

### ✅ 예상답변 방향

- 기능 단위 키 설계
    
- 부분 무효화
    
- 검색 조건별 캐시 분리
    

👉 더 나은 답변:

> “서버 상태의 정합성을 유지하면서 네트워크 비용을 줄이기 위한 구조적 선택이었습니다.”

---

# 3️⃣ 구조 설계 관련 공격 질문

---

## ❓ Q8. 클라이언트 상태 vs 서버 상태를 어떻게 구분했나요?

> 근거: 클라이언트/서버 상태 구분
> 
> 커리어12기_맹은빈_이력서

### 기대 답변

- 서버 상태 → TanStack Query
    
- UI 선택 상태 → Zustand
    
- 서버 데이터는 source of truth
    

---

## ❓ Q9. Day.js로 직접 달력을 구현한 이유는?

> 근거: 번들 사이즈 감소
> 
> 커리어12기_맹은빈_이력서

### 꼬리질문

- date-fns 대신?
    
- 직접 구현의 리스크는?
    

### 기대 답변

- moment 대비 경량
    
- 필요한 기능만 구현
    
- 외부 UI 라이브러리 배제
    

---

# 4️⃣ 공격성 있는 심화 질문

---

## ❓ Q10. 이 프로젝트에서 가장 실패했던 설계는?

면접관은 반드시 이걸 묻습니다.

### 모범 전략 답변

- 처음엔 서버 상태와 클라이언트 상태를 섞어 관리
    
- 캐시 invalidation 문제 발생
    
- Query Key Factory로 재설계
    

👉 이런 “구조적 실패 → 개선 경험” 답변이 강함

---

# 💡 면접관 총평 포인트

당신 이력서의 강점은:

- 상태관리 명확
    
- UX 수치화
    
- Query 설계 경험
    
- LLM 시스템 경험
    

약점이 될 수 있는 부분:

- 성능 수치의 구체적 개선 전후 비교 없음
    
- SSR/CSR 전략 설명 부족
    
- 실제 트래픽 기준 성능 검증 언급 없음