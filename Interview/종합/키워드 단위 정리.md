

## TanStack Query?

`비동기 상태를 관리하는` 라이브러리

-  API 요청의 상태를 더 간편하게 조회하고, 응답결과를 캐싱하고, 에러에 대응가능

### 이전에는?
React자체는 데이터를 가져오거나 업데이트하는 일관된 방법을 제시하지 않아
비동기상태를 `Redux` `Mobx`와 같은 상태관리 라이브러리를 통해 개발자가 해결하고자 함
-> 세부처리 관점에서 어려움을 겪을수있었음


## 장점?

1. 간편한 데이터관리
2. 상태관리 및 오류 처리의 용이성
3. UX개선 기능제공 (retry)등


---


## 서버 상태 와 클라이언트 상태

저장 위치 - (클라이언트 vs 서버나 외부데이터소스)
접근성 - (저장된 클라이언트만 접근가능 vs 접근권한이 있는 모든 클라이언트)
데이터관리는 어디에서 - (클라이언트 vs 서버)
지속성 - (세션간에 유지 되거나 안되거나 vs 일반적으로 유지)
보안 - (변조또는 가로채기 위험 vs 인증 및 암호화를 통해 더 안전할수있음)
성능 - (네트워크 요청이 불필요해서 빠를수있음 vs 네트워크 요청이 필요할수있어 느릴수있음)
예시 - (컴포넌트 state,쿠키 vs DB레코드,API응답)



---

## 세션,토큰

세션 - 

---


## 렉시컬 스코프?

**스코프는 식별자(변수, 함수, 클래스 등)에 접근할 수 있는 유효 범위**를 의미한다.  
자바스크립트에서는 기본적으로 다음 단위로 스코프가 형성된다.


**렉시컬 스코프는 "함수가 어디서 호출되었는지"가 아니라  
"어디에서 선언되었는지"에 따라 상위 스코프가 결정되는 규칙**이다.

즉, **코드가 작성된 위치(lexical environment)에 따라 스코프가 정적으로 결정된다.**

자바스크립트는 **렉시컬 스코프 기반 언어**다.




---



## 실행 컨텍스트?

실행 컨텍스트는 자바스크립트 엔진이 코드를 실행하기 위해 생성하는 환경으로,  
변수·함수 스코프, `this`, 실행 순서를 관리하는 단위


전역 컨텍스트 - 시작시 1회 생성
함수 컨텍스트 - 함수 호출시마다 생성
Eval 컨텍스트 - `eval` 실행시 생성

구성요소
##### 1️⃣ 렉시컬 환경

`환경 레코드` - 현재스코프의 식별자 저장소(변수,함수,매개변수,블록 스코프)
`외부환경 참조`  - 상위 렉시컬 환경을 가리키는 참조

##### 2️⃣ Variable Environment

- `var`
- 함수 선언문
- 초기 선언 저장소
##### 3️⃣ this Binding

- `this`가 가리키는 객체




---


## 클로저?

함수 객체 + 그 함수가 생성될 당시의 렉시컬 환경에 대한 참조



클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 상위 환경 경(스코프)에 접근할 수 있는 함수




렉시컬 스코프 기반의 언어이기때문에 

렉시컬 환경의 상위 환경 참조 포인터를 통한 스코프 체인에 의해

상위 스코프의 변수에 계속 접근할수있는 함수다.

클로저의 조건은

- 상위 스코프의 변수를 참조하고
- 그 함수가 상위 스코프의 밖에서 실행될 때

사용예시로는 정보은닉,고차함수등이 있으며

React에서의 useEffect,useState와 같은 여러 Hook들도 이 클로저에 기초한다.


---


## CORS 에러란?

**SOP란?** - 동일 출처 정책 같은 출처끼리만 리소스 상호작용을 허용하는 정책 
 프로토콜,호스트,포트가 같아야 동일 출처로 따짐

**CORS란?**
교차출처리소스공유 
CORS 설정이 필요
필요한 설정을 하지 않은 채 서로 다른 출처에서 리소스를 공유하려고 하면 브라우저에서 동일 출처 정책에 따라 허용되지 않은 교차 출처 리소스 공유에 대해 CORS 에러가 발생할 수 있습니다.

**해결법?**
- 먼저 백엔드 서버 개발자에게 에러가 발생하는 출처를 허용하도록 Access-Control-Allow-Origin 설정을 요청하는 방법이 있습니다.
- CORS 허용을 위한 설정 요청을 할 수 없는 경우, 동일 출처 정책을 강제하지 않는 proxy 서버를 활용해 우회하는 방법이 있습니다. Next.js의 경우 `rewrites` 를 활용할 수 있음

---

## TypeScript는 뭐고 이점은?

JS는 동적 타입언어 -> 런타임시점에 예상치못한 타입이 들어오면 타입에러가 발생

TS는 점진적 타입 언어 -> 타입을 명시할수있고 컴파일 단계에서 오류포착, 초기값을 통해 타입 추론가능

코드를 통해 어떤 타입의 값이 필요한지 쉽게 파악할 수 있어 코드의 흐름을 이해하기 쉽고 협업에 도움




---

## 가상DOM?

React는 DOM을 추상화한 자바스크립트 객체를 구성
JSX를 기반으로 UI 구조를 표현한 Virtual DOM 트리를 생성한다.  
상태 변경 시 컴포넌트 함수가 다시 실행되어 새로운 트리가 만들어지고,  
Reconciliation 과정에서 이전 트리와 비교한 결과를 바탕으로  
commit 단계에서 실제 DOM을 최소한으로 수정한다.

-> 실제 DOM 조작 최소화, UI와 상태의 일관성 보장



---


## TanStack Query?

React는 **UI 상태 관리 라이브러리**이지,  
**서버 상태(Server State) 관리 도구는 아니다.**

캐싱,재시도로직,로딩,에러상태처리등을
개발자가 전역상태관리 라이브러리들을 사용하여 직접 구현했어야했다.



> 서버 상태를 선언적으로 관리하기 위한 전용 데이터 패칭/캐싱 라이브러리

TanStack Query는 **서버 상태에 최적화**되어 있다.

이점은

자동캐싱
중복요청방지 및 재시도
에러,로딩등 상태별 로직을 선언적으로 가능