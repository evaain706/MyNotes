

## TanStack Query?

`비동기 상태를 관리하는` 라이브러리

-  API 요청의 상태를 더 간편하게 조회하고, 응답결과를 캐싱하고, 에러에 대응가능

### 이전에는?
React자체는 데이터를 가져오거나 업데이트하는 일관된 방법을 제시하지 않아
비동기상태를 `Redux` `Mobx`와 같은 상태관리 라이브러리를 통해 개발자가 해결하고자 함
-> 세부처리 관점에서 어려움을 겪을수있었음


## 장점?

1. 간편한 데이터관리
2. 상태관리 및 오류 처리의 용이성
3. UX개선 기능제공 (retry)등


---


## 서버 상태 와 클라이언트 상태

저장 위치 - (클라이언트 vs 서버나 외부데이터소스)
접근성 - (저장된 클라이언트만 접근가능 vs 접근권한이 있는 모든 클라이언트)
데이터관리는 어디에서 - (클라이언트 vs 서버)
지속성 - (세션간에 유지 되거나 안되거나 vs 일반적으로 유지)
보안 - (변조또는 가로채기 위험 vs 인증 및 암호화를 통해 더 안전할수있음)
성능 - (네트워크 요청이 불필요해서 빠를수있음 vs 네트워크 요청이 필요할수있어 느릴수있음)
예시 - (컴포넌트 state,쿠키 vs DB레코드,API응답)



---

## 세션,토큰

세션 - 

---


## 렉시컬 스코프?

**스코프는 식별자(변수, 함수, 클래스 등)에 접근할 수 있는 유효 범위**를 의미한다.  
자바스크립트에서는 기본적으로 다음 단위로 스코프가 형성된다.


**렉시컬 스코프는 "함수가 어디서 호출되었는지"가 아니라  
"어디에서 선언되었는지"에 따라 상위 스코프가 결정되는 규칙**이다.

즉, **코드가 작성된 위치(lexical environment)에 따라 스코프가 정적으로 결정된다.**

자바스크립트는 **렉시컬 스코프 기반 언어**다.




---



## 실행 컨텍스트?

실행 컨텍스트는 자바스크립트 엔진이 코드를 실행하기 위해 생성하는 환경으로,  
변수·함수 스코프, `this`, 실행 순서를 관리하는 단위


전역 컨텍스트 - 시작시 1회 생성
함수 컨텍스트 - 함수 호출시마다 생성
Eval 컨텍스트 - `eval` 실행시 생성

구성요소
##### 1️⃣ 렉시컬 환경

`환경 레코드` - 현재스코프의 식별자 저장소(변수,함수,매개변수,블록 스코프)
`외부환경 참조`  - 상위 렉시컬 환경을 가리키는 참조

##### 2️⃣ Variable Environment

- `var`
- 함수 선언문
- 초기 선언 저장소
##### 3️⃣ this Binding

- `this`가 가리키는 객체




---


## 클로저?

클로저는 함수가 선언될 당시의 렉시컬 환경을 기억하여, 함수가 외부 스코프 밖에서 실행되더라도 상위 스코프의 변수에 접근할 수 있는 현상입니다.

자바스크립트는 함수 생성 시 상위 스코프를 내부적으로 저장하기 때문에, 외부 함수가 종료되어도 해당 변수에 접근할 수 있습니다.

주로 상태 은닉이나 모듈 패턴 구현에 사용되며, React에서는 이벤트 핸들러나 useEffect에서 stale closure 문제가 발생하는 원인이 되기도 합니다.


---


## CORS 에러란?

**SOP란?** - 동일 출처 정책 같은 출처끼리만 리소스 상호작용을 허용하는 정책 
 프로토콜,호스트,포트가 같아야 동일 출처로 따짐

**CORS란?**
교차출처리소스공유 
CORS 설정이 필요
필요한 설정을 하지 않은 채 서로 다른 출처에서 리소스를 공유하려고 하면 브라우저에서 동일 출처 정책에 따라 허용되지 않은 교차 출처 리소스 공유에 대해 CORS 에러가 발생할 수 있습니다.

**해결법?**
- 먼저 백엔드 서버 개발자에게 에러가 발생하는 출처를 허용하도록 Access-Control-Allow-Origin 설정을 요청하는 방법이 있습니다.
- CORS 허용을 위한 설정 요청을 할 수 없는 경우, 동일 출처 정책을 강제하지 않는 proxy 서버를 활용해 우회하는 방법이 있습니다. Next.js의 경우 `rewrites` 를 활용할 수 있음

---

## TypeScript는 뭐고 이점은?

JS는 동적 타입언어 -> 런타임시점에 예상치못한 타입이 들어오면 타입에러가 발생

TS는 점진적 타입 언어 -> 타입을 명시할수있고 컴파일 단계에서 오류포착, 초기값을 통해 타입 추론가능

코드를 통해 어떤 타입의 값이 필요한지 쉽게 파악할 수 있어 코드의 흐름을 이해하기 쉽고 협업에 도움




---

## 가상DOM?

Virtual DOM은 **실제 DOM을 추상화한 JavaScript 객체 트리**입니다.

- React는 상태(state)가 변경되면
    
- 새로운 Virtual DOM 트리를 생성하고
    
- 이전 Virtual DOM과 비교(diffing)한 뒤
    
- 변경된 부분만 실제 DOM에 반영합니다.
    

이 과정을 **Reconciliation(재조정)**이라고 합니다.

즉,

> Virtual DOM = “메모리 상에서 관리되는 UI의 가상 표현”

---

# 2️⃣ 왜 사용하는가?

핵심은 **DOM 조작 비용 최소화**입니다.

### ① 실제 DOM은 비싸다

- DOM 변경 → Reflow → Repaint 발생 가능
    
- Layout 계산 + Style 계산 비용 큼
    
- 브라우저 렌더링 파이프라인 전체에 영향
    

직접 DOM을 조작하면 작은 변경도 전체 레이아웃 계산으로 이어질 수 있습니다.



---


## TanStack Query?

React는 **UI 상태 관리 라이브러리**이지,  
**서버 상태(Server State) 관리 도구는 아니다.**

캐싱,재시도로직,로딩,에러상태처리등을
개발자가 전역상태관리 라이브러리들을 사용하여 직접 구현했어야했다.



> 서버 상태를 선언적으로 관리하기 위한 전용 데이터 패칭/캐싱 라이브러리

TanStack Query는 **서버 상태에 최적화**되어 있다.

이점은

자동캐싱
중복요청방지 및 재시도
에러,로딩등 상태별 로직을 선언적으로 가능



---

## HTTP

get post 


---

## Next.js hydrate


- 프론트 서버단에서 필요한 데이터를 백엔드 서버에 요청해 가져옵니다.
- 받은 데이터를 활용해 프론트 서버에서 HTML을 렌더링합니다.
- 프론트 서버에서 요청한 페이지에 필요한 HTML, CSS, JavaScript 코드를 브라우저에게 보냅니다.
- 사용자는 인터랙션 할 수 없는 HTML, CSS 코드로 그려진 화면을 보게 됩니다.
- 리액트 `hydrate` 이후 사용자는 인터랙션 가능하게 됩니다.

---

## 세션 vs 토큰


## 1️⃣ 세션 (Session)

- **상태 저장 위치**: 서버
    
- **클라이언트 저장값**: Session ID (쿠키)
    
- **인증 방식**: 서버 메모리/DB 조회 기반
    
- **상태성(Stateful)**: O
    
- **서버 확장성**: 낮음 (세션 공유 필요)
    
- **로드밸런싱 대응**: Sticky Session 또는 Redis 필요
    
- **보안 리스크**: 세션 탈취(Session Hijacking)
    
- **만료 관리**: 서버에서 직접 제어
    
- **로그아웃 처리**: 서버 세션 삭제
    
- **토큰 재발급 개념**: 없음
    
- **사용 적합 환경**: 전통적 MVC, 단일 서버 구조
    

### 인증 흐름

1. 로그인 → 서버가 세션 생성
    
2. Session ID 쿠키 발급
    
3. 요청 시 쿠키 전송
    
4. 서버가 세션 조회 후 인증
    

---

## 2️⃣ 토큰 (JWT 등)

- **상태 저장 위치**: 클라이언트
    
- **서버 저장값**: 없음 (Stateless)
    
- **인증 방식**: 서명 검증 기반
    
- **상태성(Stateful)**: X
    
- **서버 확장성**: 높음
    
- **로드밸런싱 대응**: 별도 세션 공유 불필요
    
- **보안 리스크**: 토큰 탈취 시 만료 전까지 유효
    
- **만료 관리**: exp 클레임 기반
    
- **로그아웃 처리**: 기본적으로 불가능 (블랙리스트 필요)
    
- **토큰 재발급**: Refresh Token 구조 사용
    
- **사용 적합 환경**: SPA, 모바일 앱, 마이크로서비스
    

### 인증 흐름

1. 로그인 → Access Token 발급
    
2. 클라이언트 저장 (쿠키/스토리지)
    
3. 요청 시 Authorization 헤더 전송
    
4. 서버는 서명 검증만 수행




