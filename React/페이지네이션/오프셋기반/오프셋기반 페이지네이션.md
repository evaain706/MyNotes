

## 백엔드

express와 mongodb를 사용하여  더미데이터들을 생성하고 데이터들을 보내주는
간단한 api를 만들었다.

페이지네이션 구현을위해서 `currentPage` `limit` `totalItems` `totalPages` 도 반환하도록했다.

#### 더미데이터 DB테이블

```js
const mongoose = require('mongoose');

const searchItemSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
    },
    category: {
      type: String,
      required: true,
    },

    description: {
      type: String,
    },
  },
  {
    timestamps: false,
  }
);

const searchItem = mongoose.model('searchItem', searchItemSchema);

module.exports = searchItem;

```



## 프론트

#### 1.로직은 훅으로 분리

```jsx
import { useState, useEffect } from 'react';
import { instance } from '../../apis/instance';

export interface SearchItem {
  _id: string;
  name: string;
  category: string;
  description: string;
}

export function useSearch(initialLimit = 5) {
  const [searchValue, setSearchValue] = useState('');
  const [searchItems, setSearchItems] = useState<SearchItem[]>([]);
  const [searchLoading, setSearchLoading] = useState(false);

  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [totalItems, setTotalItems] = useState(0);
  const [limit, setLimit] = useState(initialLimit); //한페이지에 불러올 아이템

  const fetchData = async (page = 1, search = searchValue) => {
    try {
      setSearchLoading(true);
      const response = await instance.get(
        `/api/search?search=${search}&page=${page}&limit=${limit}`,
      );
      const data = response.data.data;
      const pagination = data.pagination;

      console.log(data);
      setSearchItems(data.items);
      setCurrentPage(pagination.currentPage);
      setTotalPages(pagination.totalPages);
      setTotalItems(pagination.totalItems);
    } catch (err) {
      console.error(err);
      setSearchItems([]);
    } finally {
      setSearchLoading(false);
    }
  };

  const handleSearchClick = () => {
    fetchData(1, searchValue);
  };

  const handlePageChange = (page: number) => {
    fetchData(page, searchValue);
  };

  useEffect(() => {
    fetchData(1, '');
  }, []);

  return {
    searchValue,
    setSearchValue,
    searchItems,
    searchLoading,
    handleSearchClick,
    currentPage,
    totalPages,
    totalItems,
    handlePageChange,
    limit,
    setLimit,
  };
}

```



#### 2. 검색창 컴포넌트

```jsx
import Input from '../Input/Input';
import Button from '../Button/Button';

interface SearchBarProps {
  value: string;
  onChange: (value: string) => void;
  onSearch: () => void;
  disabled?: boolean;
}

export default function SearchBar({
  value,
  onChange,
  onSearch,
  disabled,
}: SearchBarProps) {
  return (
    <div className='flex gap-5'>
      <Input
        className='w-full'
        value={value}
        onChange={(e) => onChange(e.target.value)}
      />
      <Button size='md' onClick={onSearch} disabled={disabled}>
        검색
      </Button>
    </div>
  );
}

```

#### 3. 검색결과 컴포넌트

```jsx

import { SearchItem } from './useSearch';

interface SearchResultsProps {
  items: SearchItem[];
  loading: boolean;
}

export default function SearchResults({ items, loading }: SearchResultsProps) {
  if (loading) return <div>로딩 중...</div>;

  if (items.length === 0)
    return <div className='mt-4 text-gray-500'>검색 결과가 없습니다</div>;

  return (
    <div className='flex flex-col'>
      {items.map((item) => (
        <div key={item._id} className='border-b border-gray-300 py-2'>
          <div>{item.name}</div>
          <div className='text-md text-gray-500'>{item.category}</div>
          <div className='text-md text-gray-800'>{item.description}</div>
        </div>
      ))}
    </div>
  );
}

```

#### 4. 페이지네이션 공통컴포넌트를 구현후 적용

```jsx
interface PaginationProps {
  currentPage: number;
  totalPages: number;
  totalItems: number;
  onPageChange: (page: number) => void;
}

const Pagination = ({
  currentPage,
  totalPages,
  onPageChange,
}: PaginationProps) => {
  if (totalPages <= 1) return null;

  const MAX_PAGE = 5;

  let startPage = Math.max(currentPage - Math.floor(MAX_PAGE / 2), 1);
  let endPage = startPage + MAX_PAGE - 1;

  if (endPage > totalPages) {
    endPage = totalPages;
    startPage = Math.max(endPage - MAX_PAGE + 1, 1);
  }

  const pageNumbers = [];
  for (let i = startPage; i <= endPage; i++) {
    pageNumbers.push(i);
  }

  return (
    <div className='mt-4 flex items-center gap-2'>
      <button
        onClick={() => onPageChange(currentPage - 1)}
        disabled={currentPage === 1}
        className='rounded border px-3 py-1 disabled:opacity-50'
      >
        이전
      </button>

      {startPage > 1 && (
        <>
          <button
            onClick={() => onPageChange(1)}
            className='rounded border px-3 py-1'
          >
            1
          </button>
          {startPage > 2 && <span>...</span>}
        </>
      )}

      {pageNumbers.map((num) => (
        <button
          key={num}
          className={`rounded border px-3 py-1 ${num === currentPage ? 'bg-blue-500 text-white' : ''}`}
          onClick={() => onPageChange(num)}
        >
          {num}
        </button>
      ))}

      {endPage < totalPages && (
        <>
          {endPage < totalPages - 1 && <span>...</span>}
          <button
            onClick={() => onPageChange(totalPages)}
            className='rounded border px-3 py-1'
          >
            {totalPages}
          </button>
        </>
      )}

      <button
        onClick={() => onPageChange(currentPage + 1)}
        disabled={currentPage === totalPages}
        className='rounded border px-3 py-1 disabled:opacity-50'
      >
        다음
      </button>
    </div>
  );
};

export default Pagination;

```


