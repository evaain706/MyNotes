

## 백엔드

```js
 res.json({
    items: itemsForPage,
    nextCursor: hasNextPage ? nextCursor : null, 
    hasNextPage,
  });
```

 express를 사용하여 get요청시 위와같은 반환을 해주는 간단한 백엔드코드를 구현하였다.



---

## 프론트


### 상위컴포넌트 전체코드


```jsx
import React, { useState, useEffect, useCallback } from 'react';
import { instance } from '../../apis/instance';
import CursorPagination from './CursorPagination';

interface Item {
  id: number;
  name: string;
  description: string;
  createdAt: string;
}

interface ApiResponse {
  items: Item[];
  nextCursor: number | null;
  hasNextPage: boolean;
}

const PaginationParent: React.FC = () => {
 
  const [items, setItems] = useState<Item[]>([]); 
  const [isLoading, setIsLoading] = useState(false); 
  const [nextCursor, setNextCursor] = useState<number | null>(null); 
  const [hasNextPage, setHasNextPage] = useState(true); 

 
  const fetchItems = useCallback(
    async (cursor: number | null) => {
     
      if (isLoading) return;
      setIsLoading(true);

      try {
      
        const params = {
          limit: 10, 
          cursor: cursor ?? undefined, 
        };

       
        const response = await instance.get<ApiResponse>('/api/items-cursor', {
          params,
        });
        const data = response.data;

      
        setItems((prevItems) => [...prevItems, ...data.items]);
        setNextCursor(data.nextCursor);
        setHasNextPage(data.hasNextPage);
      } catch (error) {
        console.error('데이터를 불러오는 중 오류가 발생했습니다.', error);
      } finally {
       
        setIsLoading(false);
      }
    },
    [isLoading],
  );

  
  const handleLoadMore = () => {
   
    if (hasNextPage && nextCursor !== null) {
      fetchItems(nextCursor);
    }
  };

  
  useEffect(() => {
    fetchItems(null); 
  }, []); 

  return (
    <div className='mx-auto my-8 max-w-2xl p-4 font-sans'>
      <h1 className='mb-6 text-center text-3xl font-bold text-gray-800'>
        아이템 목록 (커서 페이지네이션)
      </h1>

      
      <div className='flex-1 gap-10 space-y-4'>
        {items.map((item) => (
          <div
            key={item.id}
            className='rounded-lg border border-gray-200 bg-white p-4 shadow-sm transition-shadow duration-200 hover:shadow-md'
          >
            <h2 className='text-xl font-semibold text-gray-900'>
              {item.name} (ID: {item.id})
            </h2>
            <p className='mt-1 text-gray-600'>{item.description}</p>
            <p className='mt-2 text-xs text-gray-400'>
              생성일: {new Date(item.createdAt).toLocaleString('ko-KR')}
            </p>
          </div>
        ))}
      </div>

      <div className='mt-8'>
        <CursorPagination
          isLoading={isLoading}
          hasNextPage={hasNextPage}
          onLoadMore={handleLoadMore}
        />
      </div>
    </div>
  );
};

export default PaginationParent;

```

### 상태정의

```jsx
const [items, setItems] = useState<Item[]>([]);
const [isLoading, setIsLoading] = useState(false);
const [nextCursor, setNextCursor] = useState<number | null>(null);
const [hasNextPage, setHasNextPage] = useState(true);
```
- `items`: 화면에 보여줄 전체 아이템 목록
- `isLoading`: 데이터 요청중인지 아닌지를 판별할 boolean state
- `nextCursor`: 다음 요청의 시작점을 저장할 state
- `hasNextPage`: 다음 페이지 존재 여부를 확인하기위한 boolean state

### fetchItems() 데이터요청함수

```jsx

const fetchItems = useCallback(async (cursor: number | null) => {

  if (isLoading) return;
  setIsLoading(true);
  
  try {
    const params = { limit: 10, cursor: cursor ?? undefined };
    const response = await instance.get<ApiResponse>('/api/items-cursor', { params });
    
    const data = response.data;
    setItems((prev) => [...prev, ...data.items]);
    setNextCursor(data.nextCursor);
    setHasNextPage(data.hasNextPage);
    
  } catch (error) {
    console.error('데이터를 불러오는 중 오류가 발생했습니다.', error);
    
  } finally {
    setIsLoading(false);
  }
}, [isLoading]);

```
백엔드에 get요청을 날리는 함수
`limit`과 `cursor`를 params라는 변수에 정의해놓은뒤 요청

받아온데이터는 items배열에 추가하고, 다음 커서값과 다음페이지 존재여부를 갱신함

### handleLoadMore()
```jsx
const handleLoadMore = () => {
  if (hasNextPage && nextCursor !== null) {
    fetchItems(nextCursor);
  }
};
```
- 다음페이지가 있고 다음커서값이 있을경우에 버튼을 누르면 `fetchItems()`함수에
   `nextCursor`값을 담아서 실행

### useEffect()

```jsx
useEffect(() => {
  fetchItems(null);
}, []);

```
- 최초 렌더링시 1페이지 데이터를 요청하도록함

---
### 커서 페이지네이션 하위 컴포넌트

상위컴포넌트에서 전달받은 `hasNextPage`,`isLoading`,`onLoadmore` Props를 통해 
추가 데이터 요청관련 UI를 보여주는 UI전용 컴포넌트



```jsx
interface PaginationProps {
  hasNextPage: boolean;
  isLoading: boolean;
  onLoadMore: () => void;
}

const CursorPagination = ({
  hasNextPage,
  isLoading,
  onLoadMore,
}: PaginationProps) => {
  if (isLoading) {
    return (
      <div className='flex items-center justify-center p-4'>
        <div className='h-8 w-8 animate-spin rounded-full border-b-2 border-gray-900'></div>
        <span className='ml-2'>불러오는 중...</span>
      </div>
    );
  }

  if (hasNextPage) {
    return (
      <div className='flex justify-center p-4'>
        <button
          onClick={onLoadMore}
          className='rounded-full bg-blue-500 px-4 py-2 font-bold text-white'
        >
          더 보기
        </button>
      </div>
    );
  }

  return (
    <div className='p-4 text-center text-gray-500'>
      <p>모든 아이템을 불러옴</p>
    </div>
  );
};

export default CursorPagination;

```

--- 

### 흐름

- **초기 렌더링 시**  
→ `useEffect`에서 `fetchItems(null)` 호출 
→ 백엔드서버에 첫 페이지 요청  
→ 응답 데이터로 `items`, `nextCursor`, `hasNextPage` state 갱신

- **“더 보기” 클릭 시**  
 → `handleLoadMore()` 실행  
 → `fetchItems(nextCursor)` 호출  
 → 새로받은 데이터를 `items` 배열에 추가
 
- **더 이상 페이지가 없을 때**  
 → `hasNextPage = false`  
 → “모든 아이템을 불러옴” 메시지 표시